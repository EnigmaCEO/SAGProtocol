import { useEffect, useState } from 'react';
import * as ethers from 'ethers';
import { CONTRACT_ADDRESSES } from '../lib/addresses';

// Default addresses / RPC — override with env vars in .env.local
// prefer the autogenerated addresses file, then env var, then zero address
const VAULT_ADDRESS = (CONTRACT_ADDRESSES as any)?.Vault || process.env.NEXT_PUBLIC_VAULT_ADDRESS || '0x0000000000000000000000000000000000000000';
const RPC_URL = process.env.NEXT_PUBLIC_RPC_URL || 'http://localhost:8545';

// add a constant for the zero address
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';

// use the actual ABI JSON in src/lib/abis/Vault.json
// note: TypeScript JSON import may need allowJs/resolveJsonModule in tsconfig; using require keeps this simple.
const VAULT_ABI = require('../lib/abis/Vault.json');

// load treasury ABI (simple shape with getTreasuryValueUsd)
const TREASURY_ABI = require('../lib/abis/Treasury.json')?.abi ?? require('../lib/abis/Treasury.json');

// Compatibility helpers: support ethers v5 (ethers.utils.formatEther / ethers.constants.Zero)
// and ethers v6 (ethers.formatEther / ethers.Zero / ethers.JsonRpcProvider).
const FORMAT_ETHER: (v: ethers.BigNumberish) => string =
  (ethers as any).formatEther ?? (ethers as any).utils?.formatEther ?? ((v: any) => String(v));
const ZERO: any = (ethers as any).Zero ?? (ethers as any).constants?.Zero ?? 0;

// Add safe BigNumber helpers
const BigNumberFrom = (ethers as any).BigNumber?.from ?? ((v: any) => v);
function bnToString(val: any): string {
  if (val === undefined || val === null) return '0';
  if (typeof val === 'string' || typeof val === 'number') return String(val);
  if (typeof val.toString === 'function') return val.toString();
  try { return String(val); } catch { return '0'; }
}

function formatUsdFromWei(valueWei: ethers.BigNumberish) {
  try {
    const value = FORMAT_ETHER(valueWei);
    const n = Number(value);
    return `$${n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  } catch {
    return '$0.00';
  }
}

export type VaultMetrics = {
  loading: boolean;
  updatedAt: number | null;
  tvlUsd: string; // human readable USD string (formatted)
  activeLocks: number;
  uniqueDepositors: number;
  activeCount: number;
  maturedCount: number;
  activeUsd: string;
  maturedUsd: string;
  autoReturnRatePct: number; // percent, e.g. 8.75
  // new fields
  treasuryUsd6: string;        // raw usd6 from Treasury (string to avoid precision issues)
  totalActiveUsd6: string;    // sum of active deposits in usd6
  maxAvailableUsd6: string;   // treasuryUsd6 - totalActiveUsd6 (zero floor)
  error?: string | null;
};

// default state for the hook
const DEFAULT_METRICS: VaultMetrics = {
  loading: true,
  updatedAt: null,
  tvlUsd: '$0.00',
  activeLocks: 0,
  uniqueDepositors: 0,
  activeCount: 0,
  maturedCount: 0,
  activeUsd: '$0.00',
  maturedUsd: '$0.00',
  autoReturnRatePct: 0,
  treasuryUsd6: '0',
  totalActiveUsd6: '0',
  maxAvailableUsd6: '0',
  error: null,
};

export default function useVaultMetrics(pollInterval = 15000) {
  const [state, setState] = useState<VaultMetrics>(DEFAULT_METRICS);

  useEffect(() => {
    let mounted = true;

    // fast-fail if vault address is not configured
    if (!VAULT_ADDRESS || VAULT_ADDRESS === ZERO_ADDRESS) {
      setState((s) => ({ ...s, loading: false, error: 'NEXT_PUBLIC_VAULT_ADDRESS not set' }));
      return;
    }

    // debug info early to help troubleshooting local RPC / address issues
    // eslint-disable-next-line no-console
    console.debug('[useVaultMetrics] init', { RPC_URL, VAULT_ADDRESS });

    // Create a JsonRpcProvider in a way that works with ethers v5 and v6
    let provider: any;
    const JsonRpcProviderCtor = (ethers as any).JsonRpcProvider ?? (ethers as any).providers?.JsonRpcProvider;
    if (JsonRpcProviderCtor) {
      provider = new JsonRpcProviderCtor(RPC_URL);
    } else {
      setState((s) => ({ ...s, loading: false, error: 'ethers JsonRpcProvider not available' }));
      return;
    }
    const contract = new (ethers as any).Contract(VAULT_ADDRESS, VAULT_ABI, provider);

    // quick validation of contract filters / queryFilter availability
    if (typeof contract.queryFilter !== 'function' || !contract.filters) {
      setState((s) => ({ ...s, loading: false, error: 'Contract does not support event querying (ABI mismatch?)' }));
      return;
    }

    async function fetchAll() {
      try {
        // Query a limited block range to avoid long running queries on big chains.
        const currentBlock = await provider.getBlockNumber().catch(() => null);
        const fromBlock = currentBlock ? Math.max(0, currentBlock - 100_000) : 0;
        // Use defensive individual requests so we can set clear errors per query
        let depositEvents = [];
        let withdrawnEvents = [];
        let autoReturnedEvents = [];

        try {
          depositEvents = await contract.queryFilter(contract.filters.DepositAccepted?.() ?? {}, fromBlock, 'latest');
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error('[useVaultMetrics] DepositAccepted query failed', err);
          throw new Error('DepositAccepted query failed: ' + String(err));
        }
        try {
          withdrawnEvents = await contract.queryFilter(contract.filters.PrincipalWithdrawn?.() ?? {}, fromBlock, 'latest');
        } catch (err) {
          // eslint-disable-next-line no-console
          console.warn('[useVaultMetrics] PrincipalWithdrawn query failed', err);
          withdrawnEvents = [];
        }
        try {
          autoReturnedEvents = await contract.queryFilter(contract.filters.AutoReturned?.() ?? {}, fromBlock, 'latest');
        } catch (err) {
          // eslint-disable-next-line no-console
          console.warn('[useVaultMetrics] AutoReturned query failed', err);
          autoReturnedEvents = [];
        }

        // eslint-disable-next-line no-console
        console.debug('[useVaultMetrics] events', { depositEvents: depositEvents.length, withdrawnEvents: withdrawnEvents.length, autoReturnedEvents: autoReturnedEvents.length });

        // Build sets of closed ids
        const closedIds = new Set<string>();
        for (const e of withdrawnEvents) {
          const id = e.args?.id?.toString?.() ?? e.args?.[0]?.toString?.();
          if (id) closedIds.add(id);
        }
        for (const e of autoReturnedEvents) {
          const id = e.args?.tokenId?.toString?.() ?? e.args?.[0]?.toString?.();
          if (id) closedIds.add(id);
        }

        // Process deposit events: id, user, usd6 (amount in 1e6), lockUntil (uint64 seconds)
        const activeIds: string[] = [];
        const maturedIds: string[] = [];
        const activeDepositors = new Set<string>();
        let activeUsdSumUsd6 = 0; // usd6 integers
        let maturedUsdSumUsd6 = 0;

        const nowSec = Math.floor(Date.now() / 1000);
        for (const e of depositEvents) {
          const id = e.args?.id?.toString?.();
          if (!id) continue;
          if (closedIds.has(id)) continue; // already closed

          // usd6 might be named 'usd6' or 'amountUsd6' depending on build
          const rawUsd6 = e.args?.usd6 ?? e.args?.amountUsd6 ?? BigNumberFrom(0);
          const usd6 = Number(bnToString(rawUsd6) ?? '0');

          const lockUntil = Number(e.args?.lockUntil?.toString?.() ?? 0);
          const user = e.args?.user?.toString?.() ?? e.args?.[1]?.toString?.() ?? '';

          if (lockUntil > 0 && lockUntil <= nowSec) {
            maturedIds.push(id);
            maturedUsdSumUsd6 += usd6;
          } else {
            activeIds.push(id);
            activeUsdSumUsd6 += usd6;
            if (user) activeDepositors.add(user);
          }
        }

        // Compute metrics
        const activeCount = activeIds.length;
        const maturedCount = maturedIds.length;
        const activeUsd = `$${(activeUsdSumUsd6 / 1e6).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        const maturedUsd = `$${(maturedUsdSumUsd6 / 1e6).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        const uniqueDepositors = activeDepositors.size;

        // Query Treasury value (raw usd6) and compute remaining capacity
        let treasuryUsd6Bn: any = BigNumberFrom(0);
        try {
          const treasuryAddr = (CONTRACT_ADDRESSES as any)?.Treasury;
          if (treasuryAddr) {
            const treasuryContract = new (ethers as any).Contract(treasuryAddr, TREASURY_ABI, provider);
            treasuryUsd6Bn = await treasuryContract.getTreasuryValueUsd().catch(() => BigNumberFrom(0));
          }
        } catch {
          treasuryUsd6Bn = BigNumberFrom(0);
        }

        // convert big numbers to safe strings (usd6 integers)
        const treasuryUsd6Str = bnToString(treasuryUsd6Bn);
        const totalActiveUsd6Str = String(activeUsdSumUsd6); // already integer USD6 sum
        // compute maxAvailable = max(0, treasury - active)
        let maxAvailableUsd6Num = Math.max(0, Number(treasuryUsd6Str || '0') - Number(totalActiveUsd6Str || '0'));
        const maxAvailableUsd6Str = String(Math.floor(maxAvailableUsd6Num));

        // tvlUsd: sum of activeUsd (you can expand to include other sources)
        const tvlUsd = activeUsd;

        // auto-return success rate: autoReturned / (autoReturned + principalWithdrawn)
        const autoReturnedCount = autoReturnedEvents.length;
        const withdrawnCount = withdrawnEvents.length;
        const autoReturnRatePct =
          autoReturnedCount + withdrawnCount > 0
            ? (autoReturnedCount / (autoReturnedCount + withdrawnCount)) * 100
            : 0;

        // activeLocks: try to use receiptCount or userDepositsOf if available (fallback to activeCount)
        let activeLocks = activeCount;
        try {
          if (typeof contract.receiptCount === 'function') {
            // receiptCount(address) returns per-user counts — can't compute global easily here, so keep fallback
          }
        } catch {
          // ignore
        }

        if (!mounted) return;
        setState({
          loading: false,
          updatedAt: Date.now(),
          tvlUsd,
          activeLocks,
          uniqueDepositors,
          activeCount,
          maturedCount,
          activeUsd,
          maturedUsd,
          autoReturnRatePct,
          treasuryUsd6: treasuryUsd6Str,
          totalActiveUsd6: totalActiveUsd6Str,
          maxAvailableUsd6: maxAvailableUsd6Str,
          error: null,
        });
      } catch (err: any) {
        if (!mounted) return;
        // eslint-disable-next-line no-console
        console.error('[useVaultMetrics] fetchAll error', err);
        setState((s) => ({ ...s, loading: false, error: String(err?.message ?? err) }));
      }
    }

    fetchAll();
    const timer = setInterval(fetchAll, pollInterval);

    return () => {
      mounted = false;
      clearInterval(timer);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pollInterval]);

  return state;
}
